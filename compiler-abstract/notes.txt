
Итак.
Примерный минимум для ассемблера:


Регистры.
Наш абстрактный процессор будет манипулировать 8 регистрами 32-битной разрядностти
    S - регистр стека данных (от Stack)
    X - регистр стека вызовов (от eXecution)
    I - регистр инструкций (Instruction)
    F - регистр флагов (Flags)
    A, B, C, D - регистры данных

Инструкции.
Наш абстрактный процессор будет иметь очень простой набор инструкций.

Определения:
WORD 456
BYTE "This is string"

Инструкции  работы с данными:
    MOV 15, A   - поместить значение 15 в регистр A
    MOV A, B    - перенести значение из регистра A в регистр B
    MOV A, [B]  - перенести значение из регистра A в ячейку памяти по адресу в регистре B
    MOV [A], B  - перенести значение из ячейки по адресу а регистре A в регистр B
    ADD 77, C   - прибавить значение 77 к C, результат  будет в C
    ADD B, C    - прибавить значение B к C, результат  будет в C
    SUB B, C    -   вычесть значение B к C, результат  будет в C
    INC A,      - увеличить значение A на 1 (эквивалентно ADD 1, A)
    DEC A,      - уменьшить значение A на 1
    AND A, B, C - побитовое И - C = A & B
    OR  A, B, C - побитовое ИЛИ - C = A | B
    NOT A, B    - побитовое НЕ - B = !A
    CMP A, B, C - сравнение A и B
                  результат будет в C в виде знака:
                    -1 если A меньше
                    +1 если А боольше
                     0 если числа равны

Инструкции работы со стеком:
    PUSH A      - поместить на стек по адресу S значение A
    POP A       - забрать со стека по адресу S значениие в A
    PUSH A B    - поместить на стек по адресу B значение A
    POP A B     - забрать со стека по адресу B значениие в A

Инструкцции управления потоком:
  .mark:        - метка, здесь в качестве "mark" может быть любой набор символов БЕЗ пробелов и спецсимволов
    JMP mark    - перейти к метке
    JZ A, mark  - перейти к метке если A равно 0 (jump if zero)
    JNZ A, mark - перейти к метке если A не равно 0 (jump if not zero)
    JLZ A, mark - перейти к метке если A меньше 0 (jump if not zero)
    JGZ A, mark - перейти к метке если A больше 0 (jump if not zero)
    CALL mark   - вызов функции по метке
    RET         - возврат из вызова

При этом для удобства абстракции  предполоожим, что в системе сразу определены функции:
.input
.print
.exit

; Коментарии в ассемблерах обычно начинаются с точки с запятой




Пример:

.str-are-equal:
    BYTE "Numbers are equal!", 0
.str-not-equal:
    BYTE "Numbers are not equal!", 0

.main:
    MOV 15, A
    MOV 12, B
    CMP A B C ; сравнение A и B
    JNZ C, else
    .if-equal:
        MOV str-are-equal, A
        JMP if-end
    .else:
        MOV str-not-equal, A
        JMP if-end
    .end:
    CALL .exit
    RET
